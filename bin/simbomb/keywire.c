#define _CRT_SECURE_NO_WARNINGS
#ifndef MIN
#define MIN(x, y) ((x < y) ? (x) : (y))
#endif

typedef struct ByteArray {
    uint8_t *bytes;
    size_t length;
} ByteArray;

__inline__ __attribute__((always_inline)) bool write_byte_array_to_disk(const char *filename, const ByteArray arr) {
    FILE *fp = fopen(filename, "wb");
    if (!fp) {
        fprintf(stderr, "[ERROR]: Failed to open %s for writing.", filename);
        return false;
    }

    size_t wrote = fwrite(arr.bytes, sizeof(uint8_t), MIN(sizeof(arr.length), arr.length), fp);
    fflush(fp);
    fclose(fp);

    return true;
}

__inline__ __attribute__((always_inline)) ByteArray generate_ephemeral_key() {
    const size_t kEphemeralKeyLength = 32;
    ByteArray ephemeralKey = { .length = kEphemeralKeyLength };

    clock_t timestamp = clock();
    uint32_t seed = (uint32_t)(timestamp & UINT32_MAX);
    srand(seed);

    ephemeralKey.bytes = malloc(kEphemeralKeyLength);
    for (size_t idx = 0; idx < kEphemeralKeyLength; ++idx) {
        ephemeralKey.bytes[idx] = (uint8_t)(rand() % 0xFF);
    }

    return ephemeralKey;
}

__inline__ __attribute__((always_inline)) ByteArray obfuscate_with_magic_number(ByteArray data, const uint32_t magicNumber) {
    for (size_t idx = 0; idx < data.length; ++idx) {
        data.bytes[idx] = data.bytes[idx] ^ (uint8_t)(magicNumber >> (8 * idx % sizeof(magicNumber)));
    }

    return data;
}

int main() {
    const char *outputFilename = "helperkey.dat";
    const uint32_t magicNumber = 91310872U;

    ByteArray ephemeralKey = generate_ephemeral_key();
    ByteArray obfuscatedKey = obfuscate_with_magic_number(ephemeralKey, magicNumber);

    write_byte_array_to_disk(outputFilename, obfuscatedKey);
    free(ephemeralKey.bytes);

    printf("[INFO]: Generated and persisted the obfuscated helperkey (%s)\n", outputFilename);

    return EXIT_SUCCESS;
}
